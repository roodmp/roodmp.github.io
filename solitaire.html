<!DOCTYPE html>
<html lang="en" class="dark">

<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Solitaire - Mark Rood</title>
    <link rel="icon" type="image/x-icon" href="favicon.png" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&family=Instrument+Serif:ital,wght@0,400;1,400&display=swap" rel="stylesheet" />
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: {
                            50: '#EBF4FF',
                            100: '#D1E7FF',
                            200: '#A6D0FF',
                            300: '#7AB8FF',
                            400: '#4F9FFF',
                            500: '#2563EB',
                            600: '#1E40AF',
                            700: '#1E3A8A',
                            800: '#1E2A69',
                            900: '#1A1F37'
                        },
                        ai: {
                            cyan: '#06B6D4',
                            purple: '#8B5CF6',
                            blue: '#3B82F6',
                            indigo: '#6366F1',
                            violet: '#7C3AED'
                        },
                        surface: {
                            primary: '#0F0F0F',
                            secondary: '#1A1A1A',
                            tertiary: '#262626',
                            border: '#404040'
                        },
                        text: {
                            primary: '#FFFFFF',
                            secondary: '#E2E8F0',
                            tertiary: '#CBD5E1'
                        }
                    }
                }
            }
        }
    </script>
    <style>
        @keyframes single-pulse-glow {
            0%, 100% {
                border-color: rgb(156 163 175);
                box-shadow: 0 0 0 0 rgba(59, 130, 246, 0);
            }
            50% {
                border-color: rgb(59 130 246);
                box-shadow: 0 0 8px 2px rgba(59, 130, 246, 0.4);
            }
        }

        @media (prefers-color-scheme: dark) {
            @keyframes single-pulse-glow {
                0%, 100% {
                    border-color: rgb(75 85 99);
                    box-shadow: 0 0 0 0 rgba(147, 197, 253, 0);
                }
                50% {
                    border-color: rgb(147 197 253);
                    box-shadow: 0 0 8px 2px rgba(147, 197, 253, 0.4);
                }
            }
        }

        .animate-single-pulse-glow {
            animation: single-pulse-glow 2.5s ease-in-out;
        }

        .card {
            width: 128px;
            height: 176px;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        /* Mobile responsive card sizes */
        @media (max-width: 768px) {
            .card {
                width: 80px;
                height: 110px;
            }
        }

        @media (max-width: 480px) {
            .card {
                width: 54px;
                height: 76px;
            }
        }

        /* Mobile specific styles */
        @media (max-width: 768px) {
            .card .p-2 {
                padding: 0.375rem;
            }
            
            .card .text-2xl {
                font-size: 1rem;
                line-height: 1.25rem;
            }
            
            .card .text-4xl {
                font-size: 1.5rem;
                line-height: 2rem;
            }
        }

        @media (max-width: 480px) {
            .card .p-2 {
                padding: 0.25rem;
            }
            
            .card .text-2xl {
                font-size: 0.875rem;
                line-height: 1.25rem;
            }
            
            .card .text-4xl {
                font-size: 1.25rem;
                line-height: 1.75rem;
            }
        }

        /* Touch-friendly interactions */
        @media (max-width: 768px) {
            .card {
                cursor: pointer;
                touch-action: manipulation;
            }
        }

        .card-dragging {
            transform: rotate(5deg);
            transition: transform 0.1s;
        }

        .floating-particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: radial-gradient(circle, rgba(6, 182, 212, 0.8), transparent);
            border-radius: 50%;
            animation: particle-float 12s linear infinite;
        }
        
        .floating-particle:nth-child(odd) {
            background: radial-gradient(circle, rgba(139, 92, 246, 0.8), transparent);
            animation-duration: 15s;
        }
        
        @keyframes particle-float {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            33% { transform: translateY(-30px) rotate(120deg); }
            66% { transform: translateY(15px) rotate(240deg); }
        }

        .theme-logo {
            transition: all 0.3s ease;
            filter: invert(1) brightness(1.2) drop-shadow(0 0 4px rgba(255, 255, 255, 0.3));
        }

        .theme-logo:hover {
            transform: scale(1.05);
            filter: invert(1) brightness(1.3) drop-shadow(0 0 6px rgba(255, 255, 255, 0.4));
        }

        .nav-link {
            color: #E2E8F0;
            transition: all 0.2s ease;
            padding: 0.5rem;
            border-radius: 0.375rem;
            font-size: 0.875rem;
        }

        .nav-link:hover {
            color: #FFFFFF;
            transform: scale(1.05);
        }

        /* Enhanced mobile selection styles */
        .selected-card-mobile {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 10;
            position: relative;
        }

        /* Pulse animation for mobile selection */
        @keyframes mobile-selection-pulse {
            0%, 100% {
                box-shadow: 0 0 0 0 rgba(251, 191, 36, 0.7);
            }
            50% {
                box-shadow: 0 0 0 8px rgba(251, 191, 36, 0);
            }
        }

        .selected-card-mobile {
            animation: mobile-selection-pulse 2s infinite;
        }

        /* Better touch targets for mobile */
        @media (max-width: 768px) {
            .card {
                min-width: 44px;
                min-height: 44px;
            }
            
            /* Ensure buttons meet touch target guidelines */
            #newGameBtn, #undoBtn {
                min-width: 44px;
                min-height: 44px;
                padding: 12px 16px;
            }
            
            /* Enhanced undo button for mobile thumb access */
            #undoBtn {
                border-radius: 12px;
                background-color: rgb(55 65 81); /* gray-700 */
                color: white;
                border: 1px solid rgb(75 85 99); /* gray-600 */
                transition: all 0.2s ease;
            }
            
            #undoBtn:hover {
                background-color: rgb(75 85 99); /* gray-600 */
                transform: scale(1.05);
            }
            
            /* Position buttons better for thumb access */
            .game-controls {
                position: fixed;
                bottom: 20px;
                right: 20px;
                display: flex;
                gap: 12px;
                z-index: 40;
            }
            
            .game-controls button {
                box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            }
            
            /* Make stock and waste piles larger for easier tapping */
            #stockPile, #wastePile {
                min-width: 44px;
                min-height: 44px;
            }
            
            /* Foundation piles touch targets */
            #foundations .card {
                min-width: 44px;
                min-height: 44px;
            }
        }
    </style>
</head>

<body class="bg-surface-primary min-h-screen font-['Inter',system-ui,sans-serif] antialiased overflow-x-hidden">
    <!-- Floating particles background -->
    <div class="fixed inset-0 pointer-events-none overflow-hidden">
        <div class="floating-particle" style="left: 10%; top: 20%; animation-delay: 0s;"></div>
        <div class="floating-particle" style="left: 80%; top: 10%; animation-delay: -3s;"></div>
        <div class="floating-particle" style="left: 60%; top: 70%; animation-delay: -6s;"></div>
        <div class="floating-particle" style="left: 20%; top: 80%; animation-delay: -9s;"></div>
        <div class="floating-particle" style="left: 90%; top: 60%; animation-delay: -12s;"></div>
        <div class="floating-particle" style="left: 30%; top: 30%; animation-delay: -15s;"></div>
        <div class="floating-particle" style="left: 70%; top: 40%; animation-delay: -18s;"></div>
    </div>

    <header class="fixed top-4 sm:top-6 left-0 right-0 z-50 px-2 sm:px-4" role="banner">
        <nav class="bg-surface-secondary/95 backdrop-blur-md rounded-full shadow-lg hover:shadow-xl transition-all duration-300 max-w-fit mx-auto border border-surface-border/50" role="navigation" aria-label="Main navigation">
            <div class="flex items-center gap-3 sm:gap-4 px-3 sm:px-4 py-2">
                <!-- Logo -->
                <a href="about.html" class="flex-shrink-0" aria-label="Home - Mark Rood Portfolio">
                    <img src="favicon.png" alt="Mark Rood Logo" class="h-7 w-auto theme-logo" />
                </a>

                <!-- Middle navigation links -->
                <div class="flex items-center gap-3 sm:gap-4">
                    <a href="about.html" class="nav-link" aria-label="About page">About</a>
                    <a href="index.html" class="nav-link" aria-label="Resume page">Resum√©</a>
                    <a href="resources.html" class="nav-link" aria-label="Resources page">Resources</a>
                </div>
            </div>
        </nav>
    </header>

    <div class="h-24"></div>
    <main class="py-2 md:py-5" role="main">
        <div class="max-w-7xl mx-auto px-0 sm:px-4">
            <!-- Header -->
            <div class="flex justify-between items-center mb-4 sm:mb-8 gap-3">
                <h1 class="text-2xl sm:text-3xl md:text-4xl font-semibold tracking-tight text-text-primary">Solitaire</h1>
                <!-- Desktop controls -->
                <div class="hidden md:flex gap-2 sm:gap-3" role="group" aria-label="Game controls">
                    <button id="undoBtnDesktop" class="hidden p-3 text-gray-600 dark:text-gray-400 rounded-xl font-medium transition-colors hover:text-gray-900 dark:hover:text-white" title="Undo last move" aria-label="Undo last move">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6"></path>
                        </svg>
                    </button>
                    <button id="newGameBtnDesktop" class="px-3 py-2 sm:px-4 sm:py-2 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white rounded-xl font-medium transition-colors hover:bg-gray-50 dark:hover:bg-gray-700 text-sm sm:text-base" aria-label="Start a new game">
                        New Game
                    </button>
                </div>
            </div>
            
            <!-- Mobile controls - positioned for thumb access -->
            <div class="md:hidden game-controls" role="group" aria-label="Game controls">
                <button id="undoBtn" class="hidden p-3 text-white rounded-xl font-medium transition-all" title="Undo last move" aria-label="Undo last move">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6"></path>
                    </svg>
                </button>
                <button id="newGameBtn" class="px-4 py-3 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-600 text-gray-900 dark:text-white rounded-xl font-medium transition-all text-sm" aria-label="Start a new game">
                    New Game
                </button>
            </div>

            <!-- Loading state -->
            <div id="loading" class="flex items-center justify-center py-20">
                <div class="flex flex-col items-center gap-4">
                    <div class="w-12 h-12 border-4 border-primary-500 border-t-transparent rounded-full animate-spin"></div>
                    <div class="text-lg font-medium text-text-primary">Shuffling cards...</div>
                </div>
            </div>

            <!-- Game board -->
            <div id="gameBoard" class="hidden" role="application" aria-label="Solitaire game board">
                <!-- Top row - Foundations, Stock, and Waste -->
                <div class="flex justify-between items-start mb-1 sm:mb-6 overflow-x-auto">
                    <!-- Foundations -->
                    <div class="flex gap-1 sm:gap-2 md:gap-4 flex-shrink-0" id="foundations" role="group" aria-label="Foundation piles - build up from Ace to King by suit">
                        <!-- Foundation piles will be generated here -->
                    </div>

                    <div class="flex gap-1 sm:gap-2 md:gap-4 flex-shrink-0 ml-1" role="group" aria-label="Stock and waste piles">
                        <!-- Waste (discard) -->
                        <div class="flex flex-col items-center">
                            <div id="wastePile" class="card border-2 border-dashed border-gray-300 dark:border-gray-500 rounded-xl transition-all hover:border-gray-400 dark:hover:border-gray-400 cursor-pointer flex items-center justify-center" role="button" aria-label="Waste pile - top card available for play" tabindex="0">
                                <!-- Waste cards will be rendered here -->
                            </div>
                        </div>

                        <!-- Stock (new cards) -->
                        <div class="flex flex-col items-center">
                            <div id="stockPile" class="card border-2 border-dashed border-gray-300 dark:border-gray-500 rounded-xl transition-all hover:border-gray-400 dark:hover:border-gray-400 cursor-pointer hover:shadow-lg transition-shadow flex items-center justify-center" role="button" aria-label="Stock pile - click to draw new cards" tabindex="0">
                                <!-- Stock cards will be rendered here -->
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Tableau -->
                <div class="flex gap-0.5 sm:gap-1 md:gap-2 lg:gap-4 justify-center px-0.5 sm:px-1 md:px-2 lg:px-4" id="tableau" role="group" aria-label="Tableau - main playing area with 7 columns">
                    <!-- Tableau columns will be generated here -->
                </div>
            </div>
        </div>
    </main>

    <!-- Custom Modal -->
    <div id="customModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white dark:bg-gray-800 rounded-xl p-6 max-w-sm mx-4 shadow-2xl">
            <div id="modalContent" class="text-center">
                <div id="modalIcon" class="text-4xl mb-4"></div>
                <h3 id="modalTitle" class="text-lg font-semibold text-gray-900 dark:text-white mb-3"></h3>
                <p id="modalMessage" class="text-gray-600 dark:text-gray-300 mb-6"></p>
                <div id="modalButtons" class="flex gap-3 justify-center">
                    <!-- Buttons will be added dynamically -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // Game state
        let gameState = null;
        let previousGameState = null;
        let dragData = null;
        let selectedCard = null;
        let hoveredCard = null;
        let pulsingCard = null;

        const suits = ['hearts', 'diamonds', 'clubs', 'spades'];
        const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];

        const suitSymbols = {
            hearts: '‚ô•',
            diamonds: '‚ô¶',
            clubs: '‚ô£',
            spades: '‚ô†'
        };

        const suitColors = {
            hearts: 'text-red-600 dark:text-red-400',
            diamonds: 'text-red-600 dark:text-red-400',
            clubs: 'text-gray-900 dark:text-white',
            spades: 'text-gray-900 dark:text-white'
        };

        // Haptic feedback utility
        function triggerHapticFeedback(type = 'light') {
            if ('vibrate' in navigator) {
                switch (type) {
                    case 'light':
                        navigator.vibrate(50); // Quick tap for card moves
                        break;
                    case 'medium':
                        navigator.vibrate(100); // Foundation moves
                        break;
                    case 'success':
                        navigator.vibrate([100, 50, 100]); // Win condition
                        break;
                    case 'error':
                        navigator.vibrate([200, 100, 200]); // Invalid moves
                        break;
                }
            }
        }

        // Game state persistence
        const STORAGE_KEY = 'solitaire_game_state';
        const STORAGE_VERSION = '1.0';

        function saveGameState() {
            if (!gameState) return;
            
            const gameData = {
                version: STORAGE_VERSION,
                timestamp: Date.now(),
                state: gameState,
                previousState: previousGameState
            };
            
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(gameData));
            } catch (error) {
                console.warn('Failed to save game state:', error);
            }
        }

        function loadGameState() {
            try {
                const saved = localStorage.getItem(STORAGE_KEY);
                if (!saved) return null;
                
                const gameData = JSON.parse(saved);
                
                // Check version compatibility
                if (gameData.version !== STORAGE_VERSION) {
                    localStorage.removeItem(STORAGE_KEY);
                    return null;
                }
                
                // Check if save is less than 24 hours old
                const hoursSinceLastPlay = (Date.now() - gameData.timestamp) / (1000 * 60 * 60);
                if (hoursSinceLastPlay > 24) {
                    localStorage.removeItem(STORAGE_KEY);
                    return null;
                }
                
                return gameData;
            } catch (error) {
                console.warn('Failed to load game state:', error);
                localStorage.removeItem(STORAGE_KEY);
                return null;
            }
        }

        function clearSavedGame() {
            localStorage.removeItem(STORAGE_KEY);
        }

        // Swipe gesture handling for mobile
        let touchStartX = 0;
        let touchStartY = 0;
        let touchEndX = 0;
        let touchEndY = 0;
        let swipeTarget = null;

        function handleTouchStart(e, target) {
            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
            swipeTarget = target;
        }

        function handleTouchEnd(e) {
            if (!swipeTarget) return;
            
            touchEndX = e.changedTouches[0].screenX;
            touchEndY = e.changedTouches[0].screenY;
            
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            const minSwipeDistance = 50;
            
            // Check if it's a horizontal swipe and not vertical
            if (Math.abs(deltaX) > minSwipeDistance && Math.abs(deltaX) > Math.abs(deltaY)) {
                if (swipeTarget === 'stock') {
                    // Swipe left or right on stock pile to draw cards
                    handleStockClick();
                    triggerHapticFeedback('light');
                }
            }
            
            swipeTarget = null;
        }

        // Modal functions
        function showModal({ title, message, icon, buttons }) {
            const modal = document.getElementById('customModal');
            const modalTitle = document.getElementById('modalTitle');
            const modalMessage = document.getElementById('modalMessage');
            const modalIcon = document.getElementById('modalIcon');
            const modalButtons = document.getElementById('modalButtons');

            modalTitle.textContent = title;
            modalMessage.textContent = message;
            modalIcon.textContent = icon;
            
            // Clear existing buttons
            modalButtons.innerHTML = '';
            
            // Add new buttons
            buttons.forEach(button => {
                const btn = document.createElement('button');
                btn.textContent = button.text;
                let buttonClasses = 'px-4 py-2 rounded-lg font-medium transition-colors ';
                
                if (button.primary) {
                    buttonClasses += 'bg-primary-600 hover:bg-primary-700 text-white';
                } else if (button.subtle) {
                    buttonClasses += 'text-gray-600 hover:text-gray-900 dark:text-gray-400 dark:hover:text-white hover:bg-gray-100 dark:hover:bg-gray-700';
                } else {
                    buttonClasses += 'bg-gray-200 hover:bg-gray-300 dark:bg-gray-600 dark:hover:bg-gray-500 text-gray-900 dark:text-white';
                }
                
                btn.className = buttonClasses;
                btn.onclick = () => {
                    hideModal();
                    if (button.action) button.action();
                };
                modalButtons.appendChild(btn);
            });
            
            modal.classList.remove('hidden');
        }

        function hideModal() {
            document.getElementById('customModal').classList.add('hidden');
        }

        // Click outside modal to close
        document.getElementById('customModal').addEventListener('click', (e) => {
            if (e.target.id === 'customModal') {
                hideModal();
            }
        });

        // Card creation and game logic
        function createDeck() {
            const deck = [];
            suits.forEach(suit => {
                ranks.forEach(rank => {
                    deck.push({
                        suit,
                        rank,
                        faceUp: false,
                        id: `${suit}-${rank}`
                    });
                });
            });
            return shuffleDeck(deck);
        }

        function shuffleDeck(deck) {
            const shuffled = [...deck];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        function initializeGame() {
            const deck = createDeck();
            const tableau = Array(7).fill(null).map(() => []);
            
            let cardIndex = 0;
            
            // Deal cards to tableau
            for (let col = 0; col < 7; col++) {
                for (let row = 0; row <= col; row++) {
                    const card = deck[cardIndex++];
                    if (row === col) {
                        card.faceUp = true;
                    }
                    tableau[col].push(card);
                }
            }
            
            const stock = deck.slice(cardIndex);
            
            return {
                tableau,
                foundation: {
                    hearts: [],
                    diamonds: [],
                    clubs: [],
                    spades: []
                },
                stock,
                waste: [],
                score: 0,
                moves: 0,
                gameWon: false
            };
        }

        function isRed(suit) {
            return suit === 'hearts' || suit === 'diamonds';
        }

        function getRankValue(rank) {
            if (rank === 'A') return 1;
            if (rank === 'J') return 11;
            if (rank === 'Q') return 12;
            if (rank === 'K') return 13;
            return parseInt(rank);
        }

        function canPlaceOnTableau(card, targetCard) {
            if (!targetCard) {
                return getRankValue(card.rank) === 13; // Only King can go on empty column
            }
            
            return (
                getRankValue(card.rank) === getRankValue(targetCard.rank) - 1 &&
                isRed(card.suit) !== isRed(targetCard.suit)
            );
        }

        function canPlaceOnFoundation(card, foundation) {
            if (foundation.length === 0) {
                return getRankValue(card.rank) === 1; // Only Ace can start foundation
            }
            
            const topCard = foundation[foundation.length - 1];
            return (
                card.suit === topCard.suit &&
                getRankValue(card.rank) === getRankValue(topCard.rank) + 1
            );
        }

        function findAutoMoveDestination(sourceType, sourceIndex, cardIndex = -1) {
            let sourceCard = null;
            
            if (sourceType === 'waste') {
                if (gameState.waste.length === 0) return null;
                sourceCard = gameState.waste[0];
            } else {
                const column = gameState.tableau[sourceIndex];
                if (column.length === 0) return null;
                const actualCardIndex = cardIndex === -1 ? column.length - 1 : cardIndex;
                if (actualCardIndex >= column.length || !column[actualCardIndex].faceUp) return null;
                sourceCard = column[actualCardIndex];
            }
            
            // Try foundation first (higher priority) - but only for the matching suit
            if (canPlaceOnFoundation(sourceCard, gameState.foundation[sourceCard.suit])) {
                return { type: 'foundation', target: sourceCard.suit };
            }
            
            // Try tableau columns
            if (sourceType === 'waste') {
                // Waste cards can only move as single cards
                for (let i = 0; i < gameState.tableau.length; i++) {
                    const targetColumn = gameState.tableau[i];
                    const targetCard = targetColumn.length > 0 ? targetColumn[targetColumn.length - 1] : null;
                    
                    if (canPlaceOnTableau(sourceCard, targetCard)) {
                        return { type: 'tableau', target: i };
                    }
                }
            } else {
                // Tableau cards can move as sequences
                const sourceColumn = gameState.tableau[sourceIndex];
                const actualCardIndex = cardIndex === -1 ? sourceColumn.length - 1 : cardIndex;
                
                // Check if the sequence from clicked card to bottom is valid
                if (isValidSequence(sourceColumn, actualCardIndex)) {
                    for (let i = 0; i < gameState.tableau.length; i++) {
                        if (i === sourceIndex) continue; // Skip same column
                        
                        const targetColumn = gameState.tableau[i];
                        const targetCard = targetColumn.length > 0 ? targetColumn[targetColumn.length - 1] : null;
                        
                        if (canPlaceOnTableau(sourceCard, targetCard)) {
                            return { type: 'tableau', target: i };
                        }
                    }
                }
            }
            
            return null;
        }

        function isValidSequence(cards, startIndex) {
            if (startIndex >= cards.length) return false;
            
            for (let i = startIndex; i < cards.length - 1; i++) {
                const currentCard = cards[i];
                const nextCard = cards[i + 1];
                
                // Check if sequence is descending and alternating colors
                if (getRankValue(currentCard.rank) !== getRankValue(nextCard.rank) + 1 ||
                    isRed(currentCard.suit) === isRed(nextCard.suit)) {
                    return false;
                }
            }
            
            return true;
        }

        // Card rendering
        function createCardElement(card, extraClasses = '', cardContext = '') {
            const cardElement = document.createElement('div');
            cardElement.className = `card rounded-xl cursor-pointer transition-all shadow-sm ${extraClasses}`;
            
            if (!card) {
                cardElement.className += ' border-2 border-dashed border-gray-300 dark:border-gray-500 hover:border-gray-400 dark:hover:border-gray-400';
                cardElement.setAttribute('role', 'button');
                cardElement.setAttribute('aria-label', `Empty ${cardContext} pile`);
                cardElement.setAttribute('tabindex', '0');
                return cardElement;
            }
            
            cardElement.dataset.cardId = card.id;
            
            if (!card.faceUp) {
                cardElement.className += ' bg-gray-800 dark:bg-gray-900 border-2 border-blue-600 dark:border-blue-400';
                cardElement.setAttribute('aria-label', 'Face down card');
                
                // Responsive back card design
                const backSize = window.innerWidth <= 480 ? 'w-10 h-14' : window.innerWidth <= 768 ? 'w-12 h-16' : 'w-16 h-22';
                
                cardElement.innerHTML = `
                    <div class="w-full h-full flex items-center justify-center">
                        <div class="${backSize} bg-gray-700 dark:bg-gray-800 rounded-lg"></div>
                    </div>
                `;
                return cardElement;
            }
            
            cardElement.className += ' bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-600 hover:border-gray-400 dark:hover:border-gray-500';
            cardElement.draggable = true;
            
            // Add ARIA labels for face-up cards
            const suitName = card.suit.charAt(0).toUpperCase() + card.suit.slice(1);
            const cardName = `${card.rank} of ${suitName}`;
            cardElement.setAttribute('role', 'button');
            cardElement.setAttribute('aria-label', `${cardName}${cardContext ? ` in ${cardContext}` : ''}`);
            cardElement.setAttribute('tabindex', '0');
            
            // Mobile responsive text sizes
            const rankSize = window.innerWidth <= 480 ? 'text-sm' : window.innerWidth <= 768 ? 'text-lg' : 'text-2xl';
            const suitSize = window.innerWidth <= 480 ? 'text-xl' : window.innerWidth <= 768 ? 'text-2xl' : 'text-4xl';
            const padding = window.innerWidth <= 480 ? 'p-1' : window.innerWidth <= 768 ? 'p-1.5' : 'p-2';
            
            cardElement.innerHTML = `
                <div class="${padding} h-full flex flex-col justify-between">
                    <div class="${rankSize} font-bold ${suitColors[card.suit]}">
                        ${card.rank}
                    </div>
                    <div class="${suitSize} self-center ${suitColors[card.suit]}">
                        ${suitSymbols[card.suit]}
                    </div>
                    <div class="${rankSize} font-bold rotate-180 self-end ${suitColors[card.suit]}">
                        ${card.rank}
                    </div>
                </div>
            `;
            
            return cardElement;
        }

        // Game state management
        function makeMove(newState) {
            if (gameState) {
                previousGameState = JSON.parse(JSON.stringify(gameState));
            }
            gameState = newState;
            saveGameState(); // Auto-save after each move
            updateUndoButton();
            checkForWin();
        }

        function checkForWin() {
            if (!gameState) return;
            
            // Check if all foundation piles are complete (K = 13 cards each)
            const foundationComplete = Object.values(gameState.foundation).every(pile => pile.length === 13);
            
            if (foundationComplete) {
                gameState.gameWon = true;
                triggerHapticFeedback('success'); // Haptic feedback for win
                setTimeout(() => {
                    showModal({
                        title: 'Congratulations!',
                        message: `You won! üéâ\n\nMoves: ${gameState.moves}`,
                        icon: 'üéâ',
                        buttons: [
                            { text: 'New Game', primary: true, action: startNewGame },
                            { text: 'Close', primary: false, subtle: true }
                        ]
                    });
                }, 500);
                return;
            }
            
            // Check if all tableau cards are face up (potential auto-solve condition)
            const allTableauFaceUp = gameState.tableau.every(column => 
                column.every(card => card.faceUp)
            );
            
            if (allTableauFaceUp && gameState.stock.length === 0 && canAutoSolve()) {
                setTimeout(() => {
                    showModal({
                        title: 'Auto-Solve Available',
                        message: 'All cards are revealed! Would you like to auto-solve the remaining moves?',
                        icon: 'ü§ñ',
                        buttons: [
                            { text: 'Auto-Solve', primary: true, action: autoSolve },
                            { text: 'Continue Playing', primary: false }
                        ]
                    });
                }, 500);
            } else if (isGameUnwinnable()) {
                setTimeout(() => {
                    showModal({
                        title: 'Game Unwinnable',
                        message: 'This game cannot be won with the current card arrangement! üòû\n\nWould you like to start a new game?',
                        icon: 'üòû',
                        buttons: [
                            { text: 'New Game', primary: true, action: startNewGame },
                            { text: 'Close', primary: false }
                        ]
                    });
                }, 500);
            }
        }

        function canAutoSolve() {
            // Check if all remaining moves are just moving cards to foundations
            // This is a simplified check - we assume if all cards are face up, 
            // the remaining moves are deterministic foundation moves
            return gameState.tableau.some(column => column.length > 0) || gameState.waste.length > 0;
        }

        function hasAvailableMoves() {
            if (gameState.gameWon) return false;
            
            // Check if we can draw from stock
            if (gameState.stock.length > 0) {
                return true;
            }
            
            // Check all tableau cards for possible moves
            for (let sourceCol = 0; sourceCol < gameState.tableau.length; sourceCol++) {
                const sourceColumn = gameState.tableau[sourceCol];
                
                for (let cardIndex = 0; cardIndex < sourceColumn.length; cardIndex++) {
                    const card = sourceColumn[cardIndex];
                    
                    // Skip face-down cards (can't move them)
                    if (!card.faceUp) continue;
                    
                    // Check if card can move to foundation
                    if (canPlaceOnFoundation(card, gameState.foundation[card.suit])) {
                        return true;
                    }
                    
                    // Check if card sequence can move to other tableau columns
                    if (isValidSequence(sourceColumn, cardIndex)) {
                        for (let targetCol = 0; targetCol < gameState.tableau.length; targetCol++) {
                            if (targetCol === sourceCol) continue;
                            
                            const targetColumn = gameState.tableau[targetCol];
                            const targetCard = targetColumn.length > 0 ? targetColumn[targetColumn.length - 1] : null;
                            
                            if (canPlaceOnTableau(card, targetCard)) {
                                return true;
                            }
                        }
                    }
                }
            }
            
            // Check waste pile for moves
            if (gameState.waste.length > 0) {
                const wasteCard = gameState.waste[0];
                
                // Check if waste card can move to foundation
                if (canPlaceOnFoundation(wasteCard, gameState.foundation[wasteCard.suit])) {
                    return true;
                }
                
                // Check if waste card can move to tableau
                for (let targetCol = 0; targetCol < gameState.tableau.length; targetCol++) {
                    const targetColumn = gameState.tableau[targetCol];
                    const targetCard = targetColumn.length > 0 ? targetColumn[targetColumn.length - 1] : null;
                    
                    if (canPlaceOnTableau(wasteCard, targetCard)) {
                        return true;
                    }
                }
            }
            
            return false;
        }

        function isGameUnwinnable() {
            if (gameState.gameWon) return false;
            
            // If there are still cards in stock or any immediate moves available, game is not unwinnable
            if (hasAvailableMoves()) return false;
            
            // Advanced unwinnable detection
            return (
                hasUnreachableCards() ||
                hasBlockedFoundationCards() ||
                hasImpossibleSequences()
            );
        }

        function hasUnreachableCards() {
            // Check if there are face-down cards that can never be revealed
            for (let colIndex = 0; colIndex < gameState.tableau.length; colIndex++) {
                const column = gameState.tableau[colIndex];
                
                // Find first face-down card
                let firstFaceDownIndex = -1;
                for (let i = 0; i < column.length; i++) {
                    if (!column[i].faceUp) {
                        firstFaceDownIndex = i;
                        break;
                    }
                }
                
                if (firstFaceDownIndex !== -1) {
                    // Check if all face-up cards above this can be moved elsewhere
                    const faceUpCards = column.slice(firstFaceDownIndex + 1);
                    if (faceUpCards.length > 0 && !canMoveSequenceAnywhere(faceUpCards, colIndex)) {
                        return true;
                    }
                }
            }
            return false;
        }

        function hasBlockedFoundationCards() {
            // Check if required foundation cards are blocked by higher cards in tableau
            for (const suit of suits) {
                const foundation = gameState.foundation[suit];
                const nextNeededRank = foundation.length + 1; // Next rank needed (1=A, 2=2, etc.)
                
                if (nextNeededRank > 13) continue; // Foundation complete
                
                // Check if the needed card is buried under higher cards in tableau
                for (let colIndex = 0; colIndex < gameState.tableau.length; colIndex++) {
                    const column = gameState.tableau[colIndex];
                    
                    for (let cardIndex = 0; cardIndex < column.length - 1; cardIndex++) {
                        const card = column[cardIndex];
                        
                        // If we found the needed card but it's not on top
                        if (card.suit === suit && getRankValue(card.rank) === nextNeededRank) {
                            // Check if any card above it blocks its removal
                            const cardsAbove = column.slice(cardIndex + 1);
                            if (cardsAbove.some(c => c.faceUp && getRankValue(c.rank) < nextNeededRank)) {
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }

        function hasImpossibleSequences() {
            // Check for sequences that can never be built due to missing intermediate cards
            const allVisibleCards = [];
            
            // Collect all visible cards
            gameState.tableau.forEach(column => {
                column.forEach(card => {
                    if (card.faceUp) allVisibleCards.push(card);
                });
            });
            
            if (gameState.waste.length > 0) {
                allVisibleCards.push(gameState.waste[0]);
            }
            
            // Check each suit for missing critical sequences
            for (const suit of suits) {
                const suitCards = allVisibleCards.filter(c => c.suit === suit);
                const foundation = gameState.foundation[suit];
                const foundationTop = foundation.length; // 0-based, so next needed is foundationTop + 1
                
                // If we need a specific rank for foundation but there's a gap
                for (let rank = foundationTop + 1; rank <= 13; rank++) {
                    const hasRank = suitCards.some(c => getRankValue(c.rank) === rank);
                    if (!hasRank) {
                        // Missing card - check if it could be in stock/waste cycle
                        const cardsInStockWaste = gameState.stock.length + gameState.waste.length;
                        if (cardsInStockWaste === 0) {
                            return true; // Missing card and no hidden cards to reveal it
                        }
                    }
                }
            }
            
            return false;
        }

        function canMoveSequenceAnywhere(cards, excludeColumnIndex) {
            if (cards.length === 0) return false;
            
            const firstCard = cards[0];
            
            // Check if sequence can move to any tableau column
            for (let colIndex = 0; colIndex < gameState.tableau.length; colIndex++) {
                if (colIndex === excludeColumnIndex) continue;
                
                const targetColumn = gameState.tableau[colIndex];
                const targetCard = targetColumn.length > 0 ? targetColumn[targetColumn.length - 1] : null;
                
                if (canPlaceOnTableau(firstCard, targetCard)) {
                    return true;
                }
            }
            
            // Check if first card can go to foundation (only single cards to foundation)
            if (cards.length === 1 && canPlaceOnFoundation(firstCard, gameState.foundation[firstCard.suit])) {
                return true;
            }
            
            return false;
        }

        async function autoSolve() {
            let moved = true;
            let attempts = 0;
            const maxAttempts = 100; // Prevent infinite loops
            
            while (moved && attempts < maxAttempts) {
                moved = false;
                attempts++;
                
                // Try to move from tableau to foundation
                for (let colIndex = 0; colIndex < gameState.tableau.length; colIndex++) {
                    const column = gameState.tableau[colIndex];
                    if (column.length > 0) {
                        const topCard = column[column.length - 1];
                        if (topCard.faceUp && canPlaceOnFoundation(topCard, gameState.foundation[topCard.suit])) {
                            const newState = moveCardToFoundation('tableau', colIndex, topCard.suit);
                            if (newState) {
                                gameState = newState;
                                moved = true;
                                break;
                            }
                        }
                    }
                }
                
                // Try to move from waste to foundation
                if (!moved && gameState.waste.length > 0) {
                    const topCard = gameState.waste[0];
                    if (canPlaceOnFoundation(topCard, gameState.foundation[topCard.suit])) {
                        const newState = moveCardToFoundation('waste', 0, topCard.suit);
                        if (newState) {
                            gameState = newState;
                            moved = true;
                        }
                    }
                }
                
                renderGame();
                
                // Add a small delay to show the moves
                if (moved) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
            }
            
            // Final win check
            checkForWin();
        }

        function updateUndoButton() {
            const undoBtn = document.getElementById('undoBtn');
            const undoBtnDesktop = document.getElementById('undoBtnDesktop');
            
            if (previousGameState) {
                undoBtn.classList.remove('hidden');
                undoBtnDesktop?.classList.remove('hidden');
            } else {
                undoBtn.classList.add('hidden');
                undoBtnDesktop?.classList.add('hidden');
            }
        }

        // Move functions
        function moveCardToFoundation(sourceType, sourceIndex, targetSuit) {
            let sourceCard = null;
            
            if (sourceType === 'waste') {
                if (gameState.waste.length === 0) return null;
                sourceCard = gameState.waste[0];
            } else {
                const column = gameState.tableau[sourceIndex];
                if (column.length === 0) return null;
                sourceCard = column[column.length - 1];
                if (!sourceCard.faceUp) return null;
            }
            
            if (!canPlaceOnFoundation(sourceCard, gameState.foundation[targetSuit])) {
                return null;
            }
            
            const newState = JSON.parse(JSON.stringify(gameState));
            
            // Add card to foundation
            newState.foundation[targetSuit].push(sourceCard);
            
            // Remove card from source
            if (sourceType === 'waste') {
                newState.waste.shift();
            } else {
                const newColumn = [...gameState.tableau[sourceIndex]];
                newColumn.pop();
                
                // Flip the next card if it exists and is face down
                if (newColumn.length > 0 && !newColumn[newColumn.length - 1].faceUp) {
                    newColumn[newColumn.length - 1].faceUp = true;
                }
                
                newState.tableau[sourceIndex] = newColumn;
            }
            
            newState.moves += 1;
            newState.score += 10;
            
            // Haptic feedback for foundation moves
            triggerHapticFeedback('medium');
            
            return newState;
        }

        function moveCardsToTableau(sourceType, sourceIndex, cardIndex, targetColumnIndex) {
            let cardsToMove = [];
            
            if (sourceType === 'waste') {
                if (gameState.waste.length === 0) return null;
                cardsToMove = [gameState.waste[0]];
            } else {
                const sourceColumn = gameState.tableau[sourceIndex];
                if (cardIndex >= sourceColumn.length || !sourceColumn[cardIndex].faceUp) return null;
                cardsToMove = sourceColumn.slice(cardIndex);
            }
            
            const targetColumn = gameState.tableau[targetColumnIndex];
            const targetCard = targetColumn.length > 0 ? targetColumn[targetColumn.length - 1] : null;
            
            if (!canPlaceOnTableau(cardsToMove[0], targetCard)) {
                return null;
            }
            
            const newState = JSON.parse(JSON.stringify(gameState));
            
            // Add cards to target column
            newState.tableau[targetColumnIndex] = [...targetColumn, ...cardsToMove];
            
            // Remove cards from source
            if (sourceType === 'waste') {
                newState.waste.shift();
            } else {
                const newSourceColumn = gameState.tableau[sourceIndex].slice(0, cardIndex);
                
                // Flip the next card if it exists and is face down
                if (newSourceColumn.length > 0 && !newSourceColumn[newSourceColumn.length - 1].faceUp) {
                    newSourceColumn[newSourceColumn.length - 1].faceUp = true;
                }
                
                newState.tableau[sourceIndex] = newSourceColumn;
            }
            
            newState.moves += 1;
            newState.score += 5;
            
            // Haptic feedback for tableau moves
            triggerHapticFeedback('light');
            
            return newState;
        }

        // Event handlers
        function handleStockClick() {
            if (!gameState) return;
            
            if (gameState.stock.length === 0) {
                // Reset waste pile to stock
                const newState = JSON.parse(JSON.stringify(gameState));
                newState.stock = [...gameState.waste].reverse().map(card => ({ ...card, faceUp: false }));
                newState.waste = [];
                makeMove(newState);
            } else {
                // Draw from stock
                const newCard = { ...gameState.stock[0], faceUp: true };
                const newState = JSON.parse(JSON.stringify(gameState));
                newState.stock = gameState.stock.slice(1);
                newState.waste = [newCard, ...gameState.waste];
                makeMove(newState);
            }
            renderGame();
        }

        function handleCardDoubleClick(sourceType, sourceIndex, cardIndex) {
            if (!gameState) return;
            
            const destination = findAutoMoveDestination(sourceType, sourceIndex, cardIndex);
            if (!destination) return;
            
            let newState = null;
            
            if (destination.type === 'foundation') {
                newState = moveCardToFoundation(sourceType, sourceIndex, destination.target);
            } else if (destination.type === 'tableau') {
                newState = moveCardsToTableau(sourceType, sourceIndex, cardIndex, destination.target);
            }
            
            if (newState) {
                makeMove(newState);
                // Trigger pulse animation at destination
                pulsingCard = destination;
                setTimeout(() => {
                    pulsingCard = null;
                    renderGame();
                }, 2500);
            }
            
            selectedCard = null;
            renderGame();
        }

        function handleUndo() {
            if (previousGameState) {
                gameState = previousGameState;
                previousGameState = null;
                updateUndoButton();
                renderGame();
            }
        }

        function handleNewGame() {
            // Show confirmation on mobile to prevent accidental resets
            if (window.innerWidth <= 768 && gameState && gameState.moves > 0) {
                showModal({
                    title: 'New Game',
                    message: 'Are you sure you want to start a new game? Your current progress will be lost.',
                    icon: 'üÜï',
                    buttons: [
                        { text: 'Start New Game', primary: true, action: startNewGame },
                        { text: 'Cancel', primary: false }
                    ]
                });
            } else {
                startNewGame();
            }
        }

        function startNewGame() {
            gameState = initializeGame();
            previousGameState = null;
            clearSavedGame(); // Clear any saved state when starting new
            saveGameState(); // Save the new game state
            updateUndoButton();
            renderGame();
        }

        // Drag and drop
        function handleDragStart(e, sourceType, sourceIndex, cardIndex) {
            dragData = { sourceType, sourceIndex, cardIndex };
            e.dataTransfer.setData('text/plain', JSON.stringify(dragData));
            e.target.classList.add('card-dragging');
        }

        function handleDragEnd(e) {
            e.target.classList.remove('card-dragging');
            dragData = null;
        }

        function handleDragOver(e) {
            e.preventDefault();
        }

        function handleDropOnTableau(e, targetColumn) {
            e.preventDefault();
            if (!gameState || !dragData) return;
            
            const newState = moveCardsToTableau(
                dragData.sourceType,
                dragData.sourceIndex,
                dragData.cardIndex,
                targetColumn
            );
            
            if (newState) {
                makeMove(newState);
                renderGame();
            }
        }

        function handleDropOnFoundation(e, suit) {
            e.preventDefault();
            if (!gameState || !dragData) return;
            
            const newState = moveCardToFoundation(
                dragData.sourceType,
                dragData.sourceIndex,
                suit
            );
            
            if (newState) {
                makeMove(newState);
                renderGame();
            }
        }

        // Rendering
        function renderGame() {
            if (!gameState) return;
            
            document.getElementById('loading').classList.add('hidden');
            document.getElementById('gameBoard').classList.remove('hidden');
            
            renderFoundations();
            renderWastePile();
            renderStockPile();
            renderTableau();
            updateSelectedCardVisuals();
        }

        // Update visual feedback for selected cards
        function updateSelectedCardVisuals() {
            // Remove previous selection styles
            document.querySelectorAll('.card').forEach(card => {
                card.classList.remove('ring-2', 'ring-4', 'ring-blue-500', 'ring-primary-500', 'ring-yellow-400', 'shadow-lg', 'shadow-yellow-400/50', 'scale-105', 'selected-card-mobile');
            });
            
            if (selectedCard) {
                let targetElement = null;
                
                if (selectedCard.sourceType === 'waste') {
                    targetElement = document.getElementById('wastePile').querySelector('.card') || document.getElementById('wastePile');
                } else if (selectedCard.sourceType === 'tableau') {
                    const tableauContainer = document.getElementById('tableau');
                    const columnDiv = tableauContainer.children[selectedCard.sourceIndex];
                    if (columnDiv) {
                        const cards = columnDiv.querySelectorAll('.card');
                        targetElement = cards[selectedCard.cardIndex];
                    }
                }
                
                if (targetElement) {
                    // Enhanced mobile-friendly selection styling
                    if (window.innerWidth <= 768) {
                        // Mobile: larger, more visible selection with animation
                        targetElement.classList.add('ring-4', 'ring-yellow-400', 'shadow-lg', 'shadow-yellow-400/50', 'scale-105', 'selected-card-mobile');
                    } else {
                        // Desktop: subtle ring
                        targetElement.classList.add('ring-2', 'ring-primary-500');
                    }
                }
            }
        }

        function renderFoundations() {
            const foundationsContainer = document.getElementById('foundations');
            foundationsContainer.innerHTML = '';
            
            Object.entries(gameState.foundation).forEach(([suit, cards]) => {
                const foundationDiv = document.createElement('div');
                foundationDiv.className = 'flex flex-col items-center';
                
                const topCard = cards.length > 0 ? cards[cards.length - 1] : null;
                const cardElement = createCardElement(topCard, '', `${suit} foundation`);
                
                // Add pulse animation if this foundation is pulsing
                if (pulsingCard?.type === 'foundation' && pulsingCard?.target === suit) {
                    cardElement.classList.add('animate-single-pulse-glow');
                }
                
                if (!topCard) {
                    // Show suit symbol for empty foundation - responsive sizing
                    const symbolDiv = document.createElement('div');
                    const symbolSize = window.innerWidth <= 480 ? 'text-2xl' : window.innerWidth <= 768 ? 'text-3xl' : 'text-5xl';
                    symbolDiv.className = `absolute inset-0 flex items-center justify-center ${symbolSize} ${suitColors[suit]} opacity-30 pointer-events-none`;
                    symbolDiv.textContent = suitSymbols[suit];
                    cardElement.appendChild(symbolDiv);
                    cardElement.style.position = 'relative';
                }
                
                // Add event listeners
                cardElement.addEventListener('dragover', handleDragOver);
                cardElement.addEventListener('drop', (e) => handleDropOnFoundation(e, suit));
                
                // Touch support for foundations
                cardElement.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    if (selectedCard) {
                        const newState = moveCardToFoundation(
                            selectedCard.sourceType,
                            selectedCard.sourceIndex,
                            suit
                        );
                        if (newState) {
                            makeMove(newState);
                            selectedCard = null;
                            renderGame();
                        }
                    }
                });
                
                foundationDiv.appendChild(cardElement);
                foundationsContainer.appendChild(foundationDiv);
            });
        }

        function renderWastePile() {
            const wasteContainer = document.getElementById('wastePile');
            wasteContainer.innerHTML = '';
            
            if (gameState.waste.length > 0) {
                const topCard = gameState.waste[0];
                const cardElement = createCardElement(topCard, '', 'waste pile');
                
                // Set up event listeners on the card element
                cardElement.addEventListener('dragstart', (e) => handleDragStart(e, 'waste', 0, 0));
                cardElement.addEventListener('dragend', handleDragEnd);
                cardElement.addEventListener('dblclick', () => handleCardDoubleClick('waste', 0, 0));
                cardElement.addEventListener('contextmenu', (e) => {
                    e.preventDefault(); // Prevent context menu
                    handleCardDoubleClick('waste', 0, 0); // Use same logic as double-click
                });
                
                // Touch support for mobile
                cardElement.addEventListener('touchstart', (e) => {
                    cardElement.touchStartTime = Date.now();
                });
                
                cardElement.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    const touchDuration = Date.now() - cardElement.touchStartTime;
                    const now = Date.now();
                    
                    if (touchDuration < 300) {
                        if (cardElement.lastTouchTime && now - cardElement.lastTouchTime < 400) {
                            // Double tap - auto move
                            clearTimeout(cardElement.singleTapTimeout);
                            handleCardDoubleClick('waste', 0, 0);
                            cardElement.lastTouchTime = 0; // Reset to prevent triple tap
                        } else {
                            // Single tap - delay to check for double tap
                            cardElement.singleTapTimeout = setTimeout(() => {
                                handleCardClick('waste', 0, 0);
                            }, 400);
                            cardElement.lastTouchTime = now;
                        }
                    }
                });
                
                // Replace the container's classes and content with the card element
                wasteContainer.className = 'card flex items-center justify-center';
                wasteContainer.appendChild(cardElement);
            } else {
                wasteContainer.className = 'card border-2 border-dashed border-gray-300 dark:border-gray-500 rounded-xl transition-all hover:border-gray-400 dark:hover:border-gray-400 cursor-pointer flex items-center justify-center';
            }
        }

        function renderStockPile() {
            const stockContainer = document.getElementById('stockPile');
            stockContainer.innerHTML = '';
            
            if (gameState.stock.length > 0) {
                stockContainer.className = 'card bg-gray-800 dark:bg-gray-900 rounded-xl border-2 border-blue-600 dark:border-blue-400 cursor-pointer shadow-sm hover:shadow-lg transition-shadow flex items-center justify-center';
                stockContainer.innerHTML = `
                    <div class="w-full h-full flex items-center justify-center">
                        <div class="w-16 h-22 bg-gray-700 dark:bg-gray-800 rounded-lg"></div>
                    </div>
                `;
            } else {
                stockContainer.className = 'card border-2 border-dashed border-gray-300 dark:border-gray-500 rounded-xl transition-all hover:border-gray-400 dark:hover:border-gray-400 cursor-pointer hover:shadow-lg transition-shadow flex items-center justify-center';
            }
            
            stockContainer.addEventListener('click', handleStockClick);
            
            // Add swipe gesture support for mobile
            stockContainer.addEventListener('touchstart', (e) => handleTouchStart(e, 'stock'));
            stockContainer.addEventListener('touchend', handleTouchEnd);
        }

        function renderTableau() {
            const tableauContainer = document.getElementById('tableau');
            tableauContainer.innerHTML = '';
            
            gameState.tableau.forEach((column, colIndex) => {
                const columnDiv = document.createElement('div');
                columnDiv.className = 'flex flex-col items-center';
                
                const tableauColumn = document.createElement('div');
                tableauColumn.className = 'relative min-h-60 min-w-32';
                tableauColumn.addEventListener('dragover', handleDragOver);
                tableauColumn.addEventListener('drop', (e) => handleDropOnTableau(e, colIndex));
                
                if (column.length === 0) {
                    const emptyCard = createCardElement(null, '', `tableau column ${colIndex + 1}`);
                    tableauColumn.appendChild(emptyCard);
                } else {
                    column.forEach((card, cardIndex) => {
                        // Calculate spacing: tight for face-down cards, readable for face-up cards
                        let topOffset = 0;
                        for (let i = 0; i < cardIndex; i++) {
                            const prevCard = column[i];
                            topOffset += prevCard.faceUp ? 36 : 12; // 36px for face-up, 12px for face-down
                        }
                        
                        const cardWrapper = document.createElement('div');
                        cardWrapper.className = 'absolute transition-all duration-200';
                        cardWrapper.style.top = `${topOffset}px`;
                        cardWrapper.style.left = '0px';
                        
                        const cardElement = createCardElement(card, '', `tableau column ${colIndex + 1}`);
                        
                        // Add pulse animation if this card is pulsing
                        if (pulsingCard?.type === 'tableau' && 
                            pulsingCard?.target === colIndex && 
                            cardIndex === column.length - 1) {
                            cardElement.classList.add('animate-single-pulse-glow');
                        }
                        
                        if (card.faceUp) {
                            cardElement.addEventListener('dragstart', (e) => handleDragStart(e, 'tableau', colIndex, cardIndex));
                            cardElement.addEventListener('dragend', handleDragEnd);
                            cardElement.addEventListener('dblclick', () => handleCardDoubleClick('tableau', colIndex, cardIndex));
                            cardElement.addEventListener('contextmenu', (e) => {
                                e.preventDefault(); // Prevent context menu
                                handleCardDoubleClick('tableau', colIndex, cardIndex); // Use same logic as double-click
                            });
                            
                            // Hover effects for showing stack
                            cardElement.addEventListener('mouseenter', () => {
                                hoveredCard = { columnIndex: colIndex, cardIndex };
                                renderTableauHover();
                            });
                            
                            cardElement.addEventListener('mouseleave', () => {
                                hoveredCard = null;
                                renderTableauHover();
                            });
                        }
                        
                        cardWrapper.appendChild(cardElement);
                        tableauColumn.appendChild(cardWrapper);
                    });
                }
                
                columnDiv.appendChild(tableauColumn);
                tableauContainer.appendChild(columnDiv);
            });
        }

        function renderTableauHover() {
            // Simple hover highlighting - could be enhanced further
            const tableauContainer = document.getElementById('tableau');
            const cardElements = tableauContainer.querySelectorAll('.card');
            
            cardElements.forEach(cardEl => {
                cardEl.classList.remove('border-blue-400', 'dark:border-blue-300');
            });
            
            if (hoveredCard) {
                const columnDiv = tableauContainer.children[hoveredCard.columnIndex];
                const cards = columnDiv.querySelectorAll('.card');
                
                // Highlight hovered card and all cards below it
                for (let i = hoveredCard.cardIndex; i < cards.length; i++) {
                    cards[i].classList.add('border-blue-400', 'dark:border-blue-300');
                }
            }
        }

        // Mobile responsive spacing
        function getCardSpacing() {
            const isMobile = window.innerWidth <= 768;
            const isSmallMobile = window.innerWidth <= 480;
            
            if (isSmallMobile) {
                return { faceUp: 20, faceDown: 8 };
            } else if (isMobile) {
                return { faceUp: 24, faceDown: 10 };
            } else {
                return { faceUp: 36, faceDown: 12 };
            }
        }

        // Enhanced renderTableau with mobile spacing
        function renderTableau() {
            const tableauContainer = document.getElementById('tableau');
            tableauContainer.innerHTML = '';
            
            const spacing = getCardSpacing();
            
            gameState.tableau.forEach((column, colIndex) => {
                const columnDiv = document.createElement('div');
                columnDiv.className = 'flex flex-col items-center';
                
                const tableauColumn = document.createElement('div');
                tableauColumn.className = 'relative min-h-40 sm:min-h-60';
                // Adjust min-width for mobile to match card width exactly
                if (window.innerWidth <= 480) {
                    tableauColumn.style.minWidth = '54px';
                } else if (window.innerWidth <= 768) {
                    tableauColumn.style.minWidth = '80px';
                } else {
                    tableauColumn.style.minWidth = '128px';
                }
                
                tableauColumn.addEventListener('dragover', handleDragOver);
                tableauColumn.addEventListener('drop', (e) => handleDropOnTableau(e, colIndex));
                
                if (column.length === 0) {
                    const emptyCard = createCardElement(null, '', `tableau column ${colIndex + 1}`);
                    tableauColumn.appendChild(emptyCard);
                } else {
                    column.forEach((card, cardIndex) => {
                        // Calculate spacing based on screen size
                        let topOffset = 0;
                        for (let i = 0; i < cardIndex; i++) {
                            const prevCard = column[i];
                            topOffset += prevCard.faceUp ? spacing.faceUp : spacing.faceDown;
                        }
                        
                        const cardWrapper = document.createElement('div');
                        cardWrapper.className = 'absolute transition-all duration-200';
                        cardWrapper.style.top = `${topOffset}px`;
                        cardWrapper.style.left = '0px';
                        
                        const cardElement = createCardElement(card, '', `tableau column ${colIndex + 1}`);
                        
                        // Add pulse animation if this card is pulsing
                        if (pulsingCard?.type === 'tableau' && 
                            pulsingCard?.target === colIndex && 
                            cardIndex === column.length - 1) {
                            cardElement.classList.add('animate-single-pulse-glow');
                        }
                        
                        if (card.faceUp) {
                            cardElement.addEventListener('dragstart', (e) => handleDragStart(e, 'tableau', colIndex, cardIndex));
                            cardElement.addEventListener('dragend', handleDragEnd);
                            cardElement.addEventListener('dblclick', () => handleCardDoubleClick('tableau', colIndex, cardIndex));
                            cardElement.addEventListener('contextmenu', (e) => {
                                e.preventDefault(); // Prevent context menu
                                handleCardDoubleClick('tableau', colIndex, cardIndex); // Use same logic as double-click
                            });
                            
                            // Touch support for mobile
                            cardElement.addEventListener('touchstart', (e) => {
                                cardElement.touchStartTime = Date.now();
                            });
                            
                            cardElement.addEventListener('touchend', (e) => {
                                e.preventDefault();
                                const touchDuration = Date.now() - cardElement.touchStartTime;
                                const now = Date.now();
                                
                                // Double tap detection for mobile
                                if (touchDuration < 300) {
                                    if (cardElement.lastTouchTime && now - cardElement.lastTouchTime < 400) {
                                        // Double tap - auto move
                                        clearTimeout(cardElement.singleTapTimeout);
                                        handleCardDoubleClick('tableau', colIndex, cardIndex);
                                        cardElement.lastTouchTime = 0; // Reset to prevent triple tap
                                    } else {
                                        // Single tap - delay to check for double tap
                                        cardElement.singleTapTimeout = setTimeout(() => {
                                            handleCardClick('tableau', colIndex, cardIndex);
                                        }, 400);
                                        cardElement.lastTouchTime = now;
                                    }
                                }
                            });
                            
                            // Hover effects for showing stack (desktop only)
                            if (window.innerWidth > 768) {
                                cardElement.addEventListener('mouseenter', () => {
                                    hoveredCard = { columnIndex: colIndex, cardIndex };
                                    renderTableauHover();
                                });
                                
                                cardElement.addEventListener('mouseleave', () => {
                                    hoveredCard = null;
                                    renderTableauHover();
                                });
                            }
                        }
                        
                        cardWrapper.appendChild(cardElement);
                        tableauColumn.appendChild(cardWrapper);
                    });
                }
                
                columnDiv.appendChild(tableauColumn);
                tableauContainer.appendChild(columnDiv);
            });
        }

        // Add card click handler for mobile tap selection
        function handleCardClick(sourceType, sourceIndex, cardIndex) {
            if (!gameState) return;
            
            const cardData = { sourceType, sourceIndex, cardIndex };
            
            if (selectedCard && 
                selectedCard.sourceType === cardData.sourceType &&
                selectedCard.sourceIndex === cardData.sourceIndex &&
                selectedCard.cardIndex === cardData.cardIndex) {
                // Deselect if clicking the same card
                selectedCard = null;
            } else if (selectedCard) {
                // Try to move selected card to this position
                if (sourceType === 'tableau') {
                    const newState = moveCardsToTableau(
                        selectedCard.sourceType,
                        selectedCard.sourceIndex,
                        selectedCard.cardIndex,
                        sourceIndex
                    );
                    if (newState) {
                        makeMove(newState);
                        renderGame();
                    }
                }
                selectedCard = null;
            } else {
                // Select this card
                selectedCard = cardData;
            }
            
            renderGame();
        }

        // Initialize game
        document.addEventListener('DOMContentLoaded', () => {
            // Event listeners for both mobile and desktop buttons
            document.getElementById('newGameBtn').addEventListener('click', handleNewGame);
            document.getElementById('undoBtn').addEventListener('click', handleUndo);
            
            // Desktop button listeners
            const newGameBtnDesktop = document.getElementById('newGameBtnDesktop');
            const undoBtnDesktop = document.getElementById('undoBtnDesktop');
            
            if (newGameBtnDesktop) newGameBtnDesktop.addEventListener('click', handleNewGame);
            if (undoBtnDesktop) undoBtnDesktop.addEventListener('click', handleUndo);
            
            // Handle window resize for responsive spacing
            window.addEventListener('resize', () => {
                if (gameState) {
                    renderGame();
                }
            });
            
            // Start game - try to load saved state first
            setTimeout(() => {
                const savedGame = loadGameState();
                
                if (savedGame && savedGame.state) {
                    // Restore saved game
                    gameState = savedGame.state;
                    previousGameState = savedGame.previousState;
                    updateUndoButton();
                    
                    // Show restore notification on mobile
                    if (window.innerWidth <= 768) {
                        setTimeout(() => {
                            showModal({
                                title: 'Game Restored',
                                message: 'Your previous game has been restored. Continue playing or start a new game.',
                                icon: 'üîÑ',
                                buttons: [
                                    { text: 'Continue', primary: true },
                                    { text: 'New Game', primary: false, action: startNewGame }
                                ]
                            });
                        }, 500);
                    }
                } else {
                    // Start new game
                    gameState = initializeGame();
                    saveGameState();
                }
                
                renderGame();
            }, 1000);
        });
    </script>
</body>

</html>